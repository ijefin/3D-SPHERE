<!DOCTYPE html>
<html lang="pt-BR">

<head>
  <meta charset="UTF-8" />
  <title>Token de Cr√©dito de Carbono - Esfera Interativa</title>
  <style>

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: sans-serif;
      /* Usando fonte padr√£o do sistema */
      background: linear-gradient(135deg,
          #0a0f1c 0%,
          #1a2332 50%,
          #0f1419 100%);
      overflow: hidden;
      position: relative;
    }

    /* Part√≠culas de fundo animadas */
    .particles {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
    }

    .particle {
      position: absolute;
      width: 2px;
      height: 2px;
      background: rgba(64, 224, 208, 0.3);
      border-radius: 50%;
      animation: float 6s ease-in-out infinite;
    }

    @keyframes float {

      0%,
      100% {
        transform: translateY(0px) rotate(0deg);
        opacity: 0.3;
      }

      50% {
        transform: translateY(-20px) rotate(180deg);
        opacity: 0.8;
      }
    }

    /* Painel de informa√ß√µes melhorado */
    #info {
      position: absolute;
      top: 20px;
      left: 20px;
      color: white;
      background: rgba(15, 20, 25, 0.9);
      backdrop-filter: blur(15px);
      padding: 24px;
      border-radius: 20px;
      z-index: 100;
      font-size: 14px;
      border: 1px solid rgba(64, 224, 208, 0.3);
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      max-width: 320px;
    }

    #info:hover {
      transform: translateY(-4px);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      border-color: rgba(64, 224, 208, 0.5);
    }

    #info h3 {
      color: #40e0d0;
      margin-bottom: 16px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 18px;
    }

    .status {
      color: #00ff88;
      font-weight: 500;
      margin: 12px 0;
      padding: 12px 16px;
      background: linear-gradient(135deg,
          rgba(0, 255, 136, 0.1),
          rgba(0, 255, 136, 0.05));
      border-radius: 12px;
      border-left: 4px solid #00ff88;
      transition: all 0.3s ease;
    }

    .status:hover {
      background: linear-gradient(135deg,
          rgba(0, 255, 136, 0.15),
          rgba(0, 255, 136, 0.08));
      transform: translateX(4px);
    }

    .stats-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 16px;
    }

    .stat-item {
      background: rgba(64, 224, 208, 0.1);
      padding: 12px;
      border-radius: 10px;
      text-align: center;
      border: 1px solid rgba(64, 224, 208, 0.2);
      transition: all 0.3s ease;
    }

    .stat-item:hover {
      background: rgba(64, 224, 208, 0.15);
      transform: scale(1.05);
    }

    .stat-value {
      font-size: 20px;
      font-weight: 700;
      color: #40e0d0;
      display: block;
    }

    .stat-label {
      font-size: 11px;
      color: #8892b0;
      margin-top: 4px;
    }

    /* Painel de controles melhorado */
    #controls {
      position: absolute;
      top: 20px;
      right: 20px;
      color: white;
      background: rgba(15, 20, 25, 0.9);
      backdrop-filter: blur(15px);
      padding: 24px;
      border-radius: 20px;
      z-index: 100;
      font-size: 13px;
      border: 1px solid rgba(64, 224, 208, 0.3);
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      min-width: 240px;
    }

    #controls:hover {
      transform: translateY(-4px);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      border-color: rgba(64, 224, 208, 0.5);
    }

    #controls h4 {
      color: #40e0d0;
      margin-bottom: 18px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 16px;
    }

    .control-item {
      margin: 12px 0;
      padding: 8px 0;
      border-bottom: 1px solid rgba(64, 224, 208, 0.1);
    }

    .control-item:last-child {
      border-bottom: none;
    }

    .control-item p {
      color: #b0c4de;
      line-height: 1.5;
      margin: 4px 0;
    }

    .control-item strong {
      color: #40e0d0;
      font-weight: 600;
    }

    #pointCount {
      background: linear-gradient(135deg,
          rgba(64, 224, 208, 0.1),
          rgba(64, 224, 208, 0.05));
      border: 2px solid rgba(64, 224, 208, 0.3);
      color: white;
      padding: 12px 16px;
      border-radius: 12px;
      font-family: inherit;
      font-size: 13px;
      width: 100%;
      margin-top: 12px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      cursor: pointer;
    }

    #pointCount:focus {
      outline: none;
      border-color: #40e0d0;
      box-shadow: 0 0 0 4px rgba(64, 224, 208, 0.2);
      transform: scale(1.02);
    }

    #pointCount option {
      background: #1a2332;
      color: white;
      padding: 8px;
    }

    /* Indicadores de progresso */
    .progress-bar {
      width: 100%;
      height: 6px;
      background: rgba(64, 224, 208, 0.2);
      border-radius: 3px;
      overflow: hidden;
      margin: 8px 0;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #40e0d0, #00ff88);
      border-radius: 3px;
      transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
      width: 0%;
    }

    /* Notifica√ß√µes toast */
    .toast-container {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
      pointer-events: none;
    }

    .toast {
      background: rgba(15, 20, 25, 0.95);
      backdrop-filter: blur(15px);
      color: white;
      padding: 16px 24px;
      border-radius: 12px;
      margin-bottom: 12px;
      border: 1px solid rgba(64, 224, 208, 0.3);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      transform: translateY(-100px);
      opacity: 0;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      pointer-events: auto;
    }

    .toast.show {
      transform: translateY(0);
      opacity: 1;
    }

    .toast.success {
      border-color: rgba(0, 255, 136, 0.5);
    }

    .toast.warning {
      border-color: rgba(255, 170, 0, 0.5);
    }

    /* Indicador de carregamento melhorado */
    .loading-indicator {
      position: absolute;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      color: #40e0d0;
      font-size: 14px;
      opacity: 0;
      transition: all 0.4s ease;
      z-index: 100;
      background: rgba(15, 20, 25, 0.8);
      padding: 12px 24px;
      border-radius: 25px;
      border: 1px solid rgba(64, 224, 208, 0.3);
      backdrop-filter: blur(10px);
    }

    .loading-indicator.show {
      opacity: 1;
      transform: translateX(-50%) translateY(-10px);
    }

    .loading-spinner {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid rgba(64, 224, 208, 0.3);
      border-radius: 50%;
      border-top-color: #40e0d0;
      animation: spin 1s ease-in-out infinite;
      margin-right: 8px;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    /* Efeitos de hover para o canvas */
    canvas {
      cursor: crosshair;
      transition: filter 0.3s ease;
    }

    canvas:hover {
      filter: brightness(1.05) contrast(1.1);
    }

    /* Responsividade melhorada */
    @media (max-width: 768px) {

      #info,
      #controls {
        position: relative;
        margin: 15px;
        width: calc(100% - 30px);
        max-width: none;
      }

      #info {
        order: 1;
      }

      #controls {
        order: 2;
      }

      body {
        display: flex;
        flex-direction: column;
      }

      canvas {
        order: 3;
        flex: 1;
      }

      .stats-grid {
        grid-template-columns: 1fr;
      }
    }

    /* Anima√ß√µes de entrada */
    @keyframes slideInLeft {
      from {
        transform: translateX(-100px);
        opacity: 0;
      }

      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes slideInRight {
      from {
        transform: translateX(100px);
        opacity: 0;
      }

      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    #info {
      animation: slideInLeft 0.8s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #controls {
      animation: slideInRight 0.8s cubic-bezier(0.4, 0, 0.2, 1);
    }
  </style>
</head>

<body>
  <!-- Part√≠culas de fundo -->
  <div class="particles" id="particles"></div>

  <!-- Container de notifica√ß√µes -->
  <div class="toast-container" id="toastContainer"></div>

  <div id="info">
    <h3>üåç Token de Cr√©dito de Carbono</h3>
    <div id="territories" class="status">Territ√≥rios: 0</div>

    <div class="stats-grid">
      <div class="stat-item">
        <span class="stat-value" id="totalValue">0</span>
        <div class="stat-label">Valor Total</div>
      </div>
      <div class="stat-item">
        <span class="stat-value" id="coverage">0%</span>
        <div class="stat-label">Cobertura</div>
      </div>
    </div>

    <div class="progress-bar">
      <div class="progress-fill" id="progressFill"></div>
    </div>

    <div id="lastPurchase"></div>
    <div style="
          margin-top: 16px;
          font-size: 11px;
          color: #8892b0;
          line-height: 1.4;
        ">
      Cada territ√≥rio representa uma unidade de cr√©dito de carbono equivalente
      a 1 tonelada de CO‚ÇÇ
    </div>
  </div>

  <div id="controls">
    <h4>üéÆ Controles</h4>

    <div class="control-item">
      <p><strong>Mouse:</strong> Rotacionar planeta</p>
    </div>

    <div class="control-item">
      <p><strong>Scroll:</strong> Zoom in/out</p>
    </div>

    <div class="control-item">
      <p><strong>Clique:</strong> Comprar territ√≥rio</p>
    </div>

    <div class="control-item">
      <label for="pointCount" style="
            color: #40e0d0;
            font-weight: 600;
            display: block;
            margin-bottom: 8px;
          ">
        Densidade de Territ√≥rios:
      </label>
      <select id="pointCount" onchange="changePointCount()">
        <option value="1000">1.000 territ√≥rios</option>
        <option value="2000">2.000 territ√≥rios</option>
        <option value="5000">5.000 territ√≥rios</option>
        <option value="10000">10.000 territ√≥rios</option>
        <option value="25000" selected>25.000 territ√≥rios</option>
        <option value="50000">50.000 territ√≥rios</option>
      </select>
    </div>
  </div>

  <div class="loading-indicator" id="loadingIndicator">
    <div class="loading-spinner"></div>
    Gerando territ√≥rios...
  </div>

  <canvas id="three-canvas"></canvas>
  <!-- Adicionando a tag canvas explicitamente -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // ===============================
    // SISTEMA DE NOTIFICA√á√ïES
    // ===============================
    function showToast(message, type = "success") {
      const toastContainer = document.getElementById("toastContainer");
      const toast = document.createElement("div");
      toast.className = `toast ${type}`;
      toast.innerHTML = message;

      toastContainer.appendChild(toast);

      // Mostrar toast
      setTimeout(() => toast.classList.add("show"), 100);

      // Remover toast ap√≥s 3 segundos
      setTimeout(() => {
        toast.classList.remove("show");
        setTimeout(() => toastContainer.removeChild(toast), 400);
      }, 3000);
    }

    // ===============================
    // PART√çCULAS DE FUNDO MELHORADAS
    // ===============================
    function createParticles() {
      const particlesContainer = document.getElementById("particles");
      for (let i = 0; i < 60; i++) {
        const particle = document.createElement("div");
        particle.className = "particle";
        particle.style.left = Math.random() * 100 + "%";
        particle.style.top = Math.random() * 100 + "%";
        particle.style.animationDelay = Math.random() * 6 + "s";
        particle.style.animationDuration = Math.random() * 4 + 4 + "s";

        // Varia√ß√£o no tamanho das part√≠culas
        const size = Math.random() * 3 + 1;
        particle.style.width = size + "px";
        particle.style.height = size + "px";

        particlesContainer.appendChild(particle);
      }
    }

    // ===============================
    // CENA, C√ÇMERA E RENDERER
    // ===============================
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 0, 3);

    const renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: true,
      powerPreference: "high-performance",
      canvas: document.getElementById("three-canvas"), // Usando o canvas explicitamente
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = false;
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    // document.body.appendChild(renderer.domElement); // Removido, pois o canvas j√° est√° no HTML

    // ILUMINA√á√ÉO CORRIGIDA E SIMPLIFICADA
    const ambientLight = new THREE.AmbientLight(0x404080, 0.4);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0x40e0d0, 0.8);
    directionalLight.position.set(5, 5, 5);
    scene.add(directionalLight);

    const pointLight1 = new THREE.PointLight(0x00ff88, 0.6, 50);
    pointLight1.position.set(-5, 0, 5);
    scene.add(pointLight1);

    const pointLight2 = new THREE.PointLight(0x4488ff, 0.4, 50);
    pointLight2.position.set(5, -5, -5);
    scene.add(pointLight2);

    // ESFERA BASE COM MATERIAL SIMPLIFICADO
    const sphereGeometry = new THREE.SphereGeometry(1, 64, 64);

    const sphereMaterial = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        // M√∫ltiplas cores para criar o efeito Siri
        color1: { value: new THREE.Color(0xff2d55) }, // pink vibrante
        color2: { value: new THREE.Color(0xbf5af2) }, // roxo neon
        color3: { value: new THREE.Color(0x5e5ce6) }, // azul arroxeado
        color4: { value: new THREE.Color(0x64d2ff) }, // ciano claro
        color5: { value: new THREE.Color(0x32ade6) }, // azul Siri
        color6: { value: new THREE.Color(0x0a84ff) }, // azul saturado
        color7: { value: new THREE.Color(0x30d158) }, // verde neon suave
        color8: { value: new THREE.Color(0xff375f) }, // vermelho-rosado (Siri style)
        opacity: { value: 1 },
      },
      vertexShader: `
                varying vec3 vPosition;
                varying vec3 vNormal;
                varying vec3 vWorldPosition;

                void main() {
                  vPosition = position;
                  vNormal = normalize(normalMatrix * normal);
                  vWorldPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
                  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
              `,

      fragmentShader: `
        uniform float time;
        uniform vec3 color1;
        uniform vec3 color2;
        uniform vec3 color3;
        uniform vec3 color4;
        uniform vec3 color5;
        uniform vec3 color6;
        uniform vec3 color7;
        uniform vec3 color8;
        uniform float opacity;
        varying vec3 vPosition;
        varying vec3 vNormal;
        varying vec3 vWorldPosition;

        // Fun√ß√£o de ru√≠do simples (pseudo)
        float noise(vec3 p) {
          return fract(sin(dot(p, vec3(12.9898,78.233,37.719))) * 43758.5453);
        }

        // Ru√≠do suavizado
        float smoothNoise(vec3 p) {
          vec3 i = floor(p);
          vec3 f = fract(p);

          f = f*f*(3.0-2.0*f);

          float n000 = noise(i + vec3(0.0,0.0,0.0));
          float n100 = noise(i + vec3(1.0,0.0,0.0));
          float n010 = noise(i + vec3(0.0,1.0,0.0));
          float n110 = noise(i + vec3(1.0,1.0,0.0));
          float n001 = noise(i + vec3(0.0,0.0,1.0));
          float n101 = noise(i + vec3(1.0,0.0,1.0));
          float n011 = noise(i + vec3(0.0,1.0,1.0));
          float n111 = noise(i + vec3(1.0,1.0,1.0));

          float nx00 = mix(n000, n100, f.x);
          float nx10 = mix(n010, n110, f.x);
          float nx01 = mix(n001, n101, f.x);
          float nx11 = mix(n011, n111, f.x);

          float nxy0 = mix(nx00, nx10, f.y);
          float nxy1 = mix(nx01, nx11, f.y);

          return mix(nxy0, nxy1, f.z);
        }

        void main() {
          // Fresnel sutil
          vec3 viewDir = normalize(-vWorldPosition);
          float fresnel = pow(1.0 - max(0.0, dot(vNormal, viewDir)), 2.0);

          // Coordenadas + tempo no ru√≠do
          float n = smoothNoise(vPosition * 2.0 + time * 0.3);
          float n2 = smoothNoise(vPosition * 3.5 - time * 0.2);

          // Mistura din√¢mica de cores via ru√≠do
          vec3 cA = mix(color1, color3, n);
          vec3 cB = mix(color5, color7, n2);

          vec3 baseColor = mix(cA, cB, 0.5 + 0.5 * sin(time * 0.2));

          // Gradiente vertical sutil
          float vertical = smoothstep(-1.0, 1.0, vPosition.y);
          baseColor = mix(baseColor, mix(color2, color6, 0.5), vertical * 0.15);

          // Rim light suave
          vec3 rimColor = mix(color4, color8, n);
          vec3 rimLight = rimColor * fresnel * 0.3;

          // Combina√ß√£o final
          vec3 finalColor = baseColor + rimLight;

          gl_FragColor = vec4(finalColor, opacity);
        }
      `,

      transparent: true,
      side: THREE.DoubleSide,
    });

    // üåà PALETA COLORIDA PARA OS PONTOS (Inspirada na Siri)
    const siriPointColors = {
      // Cores principais que combinam com o shader
      primary: [
        0x6366f1, // Indigo vibrante
        0x8b5cf6, // Purple
        0x06b6d4, // Cyan
        0x10b981, // Emerald
        0xf59e0b, // Amber
        0xef4444, // Red
        0xec4899, // Pink
        0x84cc16, // Lime
      ],

      // Cores mais suaves para varia√ß√£o
      secondary: [
        0x818cf8, // Indigo-400
        0xa78bfa, // Purple-400
        0x22d3ee, // Cyan-400
        0x34d399, // Emerald-400
        0xfbbf24, // Amber-400
        0xf87171, // Red-400
        0xf472b6, // Pink-400
        0xa3e635, // Lime-400
      ],
    };

    // Fun√ß√£o para criar pontos com cores animadas
    function createAnimatedPointColors(pointCount, time = 0) {
      const colors = new Float32Array(pointCount * 3);
      const allColors = [
        ...siriPointColors.primary,
        ...siriPointColors.secondary,
      ];

      for (let i = 0; i < pointCount; i++) {
        // Rota√ß√£o de cor baseada no tempo e posi√ß√£o
        const colorIndex = Math.floor(
          (Math.sin(i * 0.1 + time * 2.0) * 0.5 + 0.5) * allColors.length
        );
        const color = new THREE.Color(allColors[colorIndex]);

        // Varia√ß√£o de intensidade
        const intensity = 0.7 + Math.sin(i * 0.2 + time * 1.5) * 0.3;
        color.multiplyScalar(intensity);

        const i3 = i * 3;
        colors[i3] = color.r;
        colors[i3 + 1] = color.g;
        colors[i3 + 2] = color.b;
      }

      return colors;
    }

    // Material para pontos com brilho
    function createGlowPointMaterial(baseColor) {
      return new THREE.PointsMaterial({
        color: baseColor,
        size: 3,
        transparent: true,
        opacity: 0.9,
        blending: THREE.AdditiveBlending,
        vertexColors: true, // Para usar cores individuais por ponto
      });
    }
    const sphereWireframe = new THREE.Mesh(sphereGeometry, sphereMaterial);

    // ===============================
    // SISTEMA DE PONTOS OTIMIZADO
    // ===============================
    let pointsSystem = null;
    let ownedPoints = new Set();
    let territoryCount = 0;
    let pointPositions = [];
    let animationTime = 0;
    let totalPoints = 0;

    function generatePoints(count) {
      const loadingIndicator = document.getElementById("loadingIndicator");
      loadingIndicator.classList.add("show");

      if (pointsSystem) planetGroup.remove(pointsSystem);

      const pointGeometry = new THREE.SphereGeometry(0.008, 8, 8);

      const availableMaterial = new THREE.MeshBasicMaterial({
        color: 0x4488ff,
        transparent: true,
        opacity: 0.8,
      });

      pointsSystem = new THREE.InstancedMesh(
        pointGeometry,
        availableMaterial,
        count
      );

      pointPositions = [];
      ownedPoints.clear();
      territoryCount = 0;
      totalPoints = count;

      const matrix = new THREE.Matrix4();
      const colors = [];

      for (let i = 0; i < count; i++) {
        // Distribui√ß√£o fibonacci
        const phi = Math.acos(-1 + (2 * i) / count);
        const theta = Math.sqrt(count * Math.PI) * phi;
        const radius = 1.01;
        const x = Math.cos(theta) * Math.sin(phi) * radius;
        const y = Math.sin(theta) * Math.sin(phi) * radius;
        const z = Math.cos(phi) * radius;

        pointPositions[i] = new THREE.Vector3(x, y, z);

        const scale = 0.8 + Math.random() * 0.4;
        matrix.makeScale(scale, scale, scale);
        matrix.setPosition(x, y, z);
        pointsSystem.setMatrixAt(i, matrix);

        const baseColor = new THREE.Color(0x4488ff);
        colors.push(baseColor.r, baseColor.g, baseColor.b);
      }

      pointsSystem.instanceMatrix.needsUpdate = true;

      const colorAttribute = new THREE.InstancedBufferAttribute(
        new Float32Array(colors),
        3
      );
      pointsSystem.geometry.setAttribute("instanceColor", colorAttribute);

      planetGroup.add(pointsSystem);

      updateStats();
      showToast(
        `‚ú® ${count.toLocaleString()} territ√≥rios gerados com sucesso!`,
        "success"
      );

      setTimeout(() => {
        loadingIndicator.classList.remove("show");
      }, 1000);
    }

    function updateStats() {
      const coverage =
        totalPoints > 0
          ? ((territoryCount / totalPoints) * 100).toFixed(1)
          : 0;
      const value = territoryCount * 25;

      document.getElementById(
        "territories"
      ).textContent = `Territ√≥rios: ${territoryCount.toLocaleString()}`;
      document.getElementById(
        "totalValue"
      ).textContent = `R$ ${value.toLocaleString()}`;
      document.getElementById("coverage").textContent = `${coverage}%`;

      const progressFill = document.getElementById("progressFill");
      progressFill.style.width = `${coverage}%`;
    }

    // ===============================
    // GRUPO PLANETA
    // ===============================
    const planetGroup = new THREE.Group();
    planetGroup.add(sphereWireframe);
    scene.add(planetGroup);

    // ===============================
    // CONTROLES SUAVIZADOS
    // ===============================
    let isMouseDown = false;
    let mouseX = 0,
      mouseY = 0;
    let targetRotationX = 0,
      targetRotationY = 0;
    let currentRotationX = 0,
      currentRotationY = 0;
    let rotationVelocityX = 0,
      rotationVelocityY = 0;

    renderer.domElement.addEventListener("mousedown", (event) => {
      isMouseDown = true;
      mouseX = event.clientX;
      mouseY = event.clientY;
      renderer.domElement.style.cursor = "grabbing";
    });

    renderer.domElement.addEventListener("mouseup", () => {
      isMouseDown = false;
      renderer.domElement.style.cursor = "crosshair";
    });

    renderer.domElement.addEventListener("mousemove", (event) => {
      if (!isMouseDown) return;
      const deltaX = event.clientX - mouseX;
      const deltaY = event.clientY - mouseY;

      targetRotationY += deltaX * 0.008;
      targetRotationX += deltaY * 0.008;

      mouseX = event.clientX;
      mouseY = event.clientY;
    });

    renderer.domElement.addEventListener("wheel", (event) => {
      const zoomSpeed = 0.08;
      const minDistance = 1.8;
      const maxDistance = 6;

      if (event.deltaY > 0) camera.position.multiplyScalar(1 + zoomSpeed);
      else camera.position.multiplyScalar(1 - zoomSpeed);

      const distance = camera.position.length();
      if (distance < minDistance)
        camera.position.normalize().multiplyScalar(minDistance);
      else if (distance > maxDistance)
        camera.position.normalize().multiplyScalar(maxDistance);
      event.preventDefault();
    });

    // ===============================
    // SISTEMA DE COMPRA
    // ===============================
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let isClicking = false;

    renderer.domElement.addEventListener("click", (event) => {
      if (isClicking || !pointsSystem) return;
      isClicking = true;

      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObject(pointsSystem);

      if (intersects.length > 0) {
        const instanceId = intersects[0].instanceId;
        if (!ownedPoints.has(instanceId)) {
          purchaseTerritory(instanceId);
        } else {
          showToast(
            `‚ö† Territ√≥rio #${instanceId} j√° foi adquirido!`,
            "warning"
          );
        }
      }

      setTimeout(() => (isClicking = false), 100);
    });

    function purchaseTerritory(instanceId) {
      ownedPoints.add(instanceId);
      territoryCount++;

      const purchasedColor = new THREE.Color().setHSL(
        0.25 + Math.random() * 0.15,
        0.8,
        0.6
      );

      pointsSystem.setColorAt(instanceId, purchasedColor);
      pointsSystem.instanceColor.needsUpdate = true;

      const matrix = new THREE.Matrix4();
      pointsSystem.getMatrixAt(instanceId, matrix);
      const position = pointPositions[instanceId];
      const scale = 1.3 + Math.random() * 0.2;
      matrix.makeScale(scale, scale, scale);
      matrix.setPosition(position.x, position.y, position.z);
      pointsSystem.setMatrixAt(instanceId, matrix);
      pointsSystem.instanceMatrix.needsUpdate = true;

      updateStats();
      showToast(
        `‚úì Territ√≥rio #${instanceId} adquirido com sucesso!`,
        "success"
      );

      createPurchaseEffect(position);
    }

    function createPurchaseEffect(position) {
      const particleCount = 8;

      for (let i = 0; i < particleCount; i++) {
        const particleGeometry = new THREE.SphereGeometry(0.01, 4, 4);
        const particleMaterial = new THREE.MeshBasicMaterial({
          color: 0x00ff88,
          transparent: true,
          opacity: 0.8,
        });

        const particle = new THREE.Mesh(particleGeometry, particleMaterial);
        particle.position.copy(position);

        const direction = new THREE.Vector3(
          (Math.random() - 0.5) * 2,
          (Math.random() - 0.5) * 2,
          (Math.random() - 0.5) * 2
        ).normalize();

        particle.velocity = direction.multiplyScalar(0.015);
        particle.life = 1.0;

        scene.add(particle);

        const animateParticle = () => {
          particle.position.add(particle.velocity);
          particle.life -= 0.02;
          particle.material.opacity = particle.life;
          particle.scale.multiplyScalar(0.98);

          if (particle.life > 0) {
            requestAnimationFrame(animateParticle);
          } else {
            scene.remove(particle);
            particle.geometry.dispose();
            particle.material.dispose();
          }
        };

        animateParticle();
      }
    }

    // ===============================
    // FUN√á√ÉO MUDAR QUANTIDADE DE PONTOS
    // ===============================
    function changePointCount() {
      const count = parseInt(document.getElementById("pointCount").value);
      generatePoints(count);
    }

    // ===============================
    // ANIMA√á√ÉO PRINCIPAL OTIMIZADA
    // ===============================
    function animate() {
      requestAnimationFrame(animate);
      animationTime += 0.006;

      // Atualizar shader da esfera
      if (sphereMaterial.uniforms) {
        sphereMaterial.uniforms.time.value = animationTime;
      }

      // Aplicar in√©rcia na rota√ß√£o
      if (!isMouseDown) {
        rotationVelocityX *= 0.95;
        rotationVelocityY *= 0.95;
        targetRotationX += rotationVelocityX;
        targetRotationY += rotationVelocityY;
      }

      // Suavizar rota√ß√£o
      currentRotationX += (targetRotationX - currentRotationX) * 0.05;
      currentRotationY += (targetRotationY - currentRotationY) * 0.05;

      // Limitar rota√ß√£o vertical para evitar invers√£o
      currentRotationX = Math.max(
        -Math.PI / 2 + 0.01,
        Math.min(Math.PI / 2 - 0.01, currentRotationX)
      );

      // Posicionar c√¢mera
      const distance = camera.position.length();
      camera.position.x =
        distance * Math.sin(currentRotationY) * Math.cos(currentRotationX);
      camera.position.y = distance * Math.sin(currentRotationX);
      camera.position.z =
        distance * Math.cos(currentRotationY) * Math.cos(currentRotationX);

      camera.lookAt(0, 0, 0);

      // Rota√ß√£o autom√°tica suave
      planetGroup.rotation.y += 0.0005;

      // Anima√ß√£o sutil das luzes
      pointLight1.intensity = 0.6 + Math.sin(animationTime * 1.2) * 0.2;
      pointLight2.intensity = 0.4 + Math.cos(animationTime * 1.5) * 0.1;

      renderer.render(scene, camera);
    }

    // ===============================
    // RESPONSIVIDADE
    // ===============================
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // ===============================
    // CONTROLES TOUCH
    // ===============================
    let touchStartX = 0,
      touchStartY = 0;
    let initialDistance = 0;

    renderer.domElement.addEventListener("touchstart", (e) => {
      e.preventDefault();
      if (e.touches.length === 1) {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
      } else if (e.touches.length === 2) {
        initialDistance = Math.hypot(
          e.touches[0].clientX - e.touches[1].clientX,
          e.touches[0].clientY - e.touches[1].clientY
        );
      }
    });

    renderer.domElement.addEventListener("touchmove", (e) => {
      e.preventDefault();
      if (e.touches.length === 1) {
        const deltaX = e.touches[0].clientX - touchStartX;
        const deltaY = e.touches[0].clientY - touchStartY;

        targetRotationY += deltaX * 0.008;
        targetRotationX += deltaY * 0.008;

        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
      } else if (e.touches.length === 2) {
        const newDistance = Math.hypot(
          e.touches[0].clientX - e.touches[1].clientX,
          e.touches[0].clientY - e.touches[1].clientY
        );
        const zoomSpeed = 0.005;
        if (initialDistance !== 0) {
          if (newDistance > initialDistance)
            camera.position.multiplyScalar(1 - zoomSpeed);
          else camera.position.multiplyScalar(1 + zoomSpeed);
        }
        initialDistance = newDistance;
      }
    });

    // ===============================
    // INICIALIZA√á√ÉO
    // ===============================
    createParticles();
    generatePoints(2000);
    animate();

    // Mensagem de boas-vindas
    setTimeout(() => {
      showToast(
        "üåç Bem-vindo ao Token de Cr√©dito de Carbono! Clique nos territ√≥rios para compr√°-los.",
        "success"
      );
    }, 1000);
  </script>
</body>

</html>